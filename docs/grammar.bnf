// MIT License
//
// Copyright (c) 2025 Leonard SchÃ¼tz
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// ------ Grammar ------

Program ::= TopLevelItem*

TopLevelItem ::= ImportDecl
               | FnDecl
               | VarDecl
               | TypeAliasDecl
               | StructDecl
               | InterfaceDecl
               | UnionDecl
               | EnumDecl
               | ImplDecl
               | Stmt

// ------ Import Statement ------

ImportDecl ::= AttributeList? "import" ImportPath ImportAsItem?

ImportPath ::= Id ("." Id)* ("." "*")?

ImportAsItem ::= "as" Id

// ------ Declarations ------

DeclMod ::= "export"
          | "internal"
          | "public"
          | "private"
          | "static"
          | "final"

// ------ Function Declaration ------

FnDecl ::= AttributeList? DeclMod* "fn" Id GenericParamList? FnParamList? FnReturnAnnot? FnBody

FnParamList ::= "(" FnParam* ")"

FnParam ::= "..."? NameDecl

FnReturnAnnot ::= "->" Type

FnBody ::= FnExprBody
         | FnBlockBody

FnExprBody ::= "=" ExprLikeStmt

FnBlockBody ::= Block

// ------ Variable Declarations ------

VarDecl ::= AttributeList? DeclMod* ("const" | "let") VarDeclTarget ("=" Expr)?

VarDeclTarget ::= NameDecl
                | UnpackTarget

// ------ Typealias Declarations ------

TypeAliasDecl ::= AttributeList? DeclMod* "typealias" Id GenericParamList? ("=" Type)?

// ------ Struct Declarations ------

StructDecl ::= AttributeList? DeclMod* "struct" Id GenericParamList? StructBody

StructBody ::= "{" StructItem* "}"

StructItem ::= VarDecl
             | TypeAliasDecl

// ------ Interface Declarations ------

InterfaceDecl ::= AttributeList? DeclMod* "interface" Id GenericParamList? InterfaceExtends* InterfaceBody

InterfaceExtends ::= "extends" Type*

InterfaceBody ::= "{" InterfaceItem* "}"

InterfaceItem ::= FnDecl
                | TypeAliasDecl

// ------ Union Declarations ------

UnionDecl ::= AttributeList? DeclMod* "union" GenericParamList? UnionBody

UnionBody ::= "{" UnionItem* "}"

UnionItem ::= Id UnionItemParams?

UnionItemParams ::= "(" NameDecl* ")"

// ------ Enum Declarations ------

EnumDecl ::= AttributeList? DeclMod* "enum" EnumHeader EnumBody

EnumHeader ::= Id TypeAnnotation
             | "flags" Id TypeAnnotation?

EnumBody ::= "{" EnumItem* "}"

EnumItem ::= Id ("=" Expr)?

// ------ Impl Declarations ------

ImplDecl ::= AttributeList? "impl" GenericParamList? ImplTarget ImplBody

ImplTarget ::= ImplTypeTarget
             | ImplInterfaceTarget

ImplTypeTarget ::= Type

ImplInterfaceTarget ::= Type "for" Type

ImplBody ::= "{" ImplItem* "}"

ImplItem ::= FnDecl
           | TypeAliasDecl

// ------ Statements ------

Block ::= "{" Stmt* "}"

Stmt ::= VarDecl
       | ImportDecl
       | DeferStmt
       | ExprLikeStmt

ExprLikeStmt ::= "return" Expr?
               | "break"
               | "continue"
               | ForStmt
               | WhileStmt
               | LoopStmt
               | Expr

BlockOrExpr ::= Block | ExprLikeStmt

// ------ Defer Statement ------

DeferStmt ::= "defer" BlockOrExpr

// ------ For Statement ------

ForStmt ::= "for" VarDeclTarget "in" Expr BlockOrExpr

// ------ While Statement ------

WhileStmt ::= "while" ConditionTarget BlockOrExpr

// ------ If Statement ------

IfStmt ::= "if" ConditionTarget BlockOrExpr IfElseCase?

IfElseCase ::= "else" BlockOrExpr

// ------ Loop Statement ------

LoopStmt ::= "loop" BlockOrExpr

// ------ Match Statement ------

MatchStmt ::= "match" Expr? MatchBody

MatchBody ::= "{" MatchArm* "}"

MatchArm ::= MatchPattern MatchPatternCondition? "=>" BlockOrExpr

MatchPattern ::= MatchPatternTuple
               | MatchPatternExpr
               | MatchPatternIs
               | MatchPatternIn
               | MatchPatternElse

MatchPatternTuple ::= TupleLiteral

MatchPatternExpr ::= Expr

MatchPatternIs ::= "is" Type UnpackTarget?

MatchPatternIn ::= "in" Expr

MatchPatternElse ::= "else"

MatchPatternCondition ::= "if" Expr

// ------ Select Statement ------

SelectStmt ::= "select" SelectBody

SelectBody ::= "{" SelectArm* "}"

SelectArm ::= SelectWhenArm
            | SelectElseArm

SelectWhenArm ::= "when" Expr SelectArmResultHandler

SelectElseArm ::= "else" SelectArmResultHandler

SelectArmResultHandler ::= "=>" BlockOrExpr

// ------ Expressions ------

Expr ::= Expr InfixOp Expr
       | PrefixOp Expr
       | Expr PostfixOp
       | Expr PostfixExpr
       | Expr ("as" | "as?") Type
       | IfStmt
       | MatchStmt
       | SelectStmt
       | Atom

PostfixExpr ::= GenericArgumentList
              | PostfixCallExpr
              | PostfixIndexExpr
              | PostfixMemberExpr

PostfixCallExpr ::= CallArgumentList
                  | CallArgumentList? LambdaLiteral

CallArgumentList ::= "(" CallArgument* ")"

CallArgument ::= Expr
               | "." Id "=" Expr

PostfixIndexExpr ::= "[" Expr* "]"

PostfixMemberExpr ::= "." Id

// ------ Types ------

Type ::= TypePathItem ("." TypePathItem)* "?"

TypePathItem ::= Id GenericArgumentList

GenericParamList ::= "<" GenericParamItem* ">"

GenericParamItem ::= Id (":" Type ("&" Type)*)?

GenericArgumentList ::= "<" Type* ">"

NameDecl ::= Id TypeAnnotation?

TypeAnnotation ::= ":" Type

// ------ Literals ------

Atom ::= Id
          | Number
          | String
          | "true" | "false"
          | "null"
          | LambdaLiteral
          | "(" Expr ")"
          | TupleLiteral
          | ListLiteral
          | MapLiteral
          | Block

Id ::= "identifier"

Number ::= Integer | Float

Integer ::= (HexInteger | DecimalInteger | OctalInteger | BinaryInteger) NumberSuffix?

HexInteger ::= "0x" HexDigit+

DecimalInteger ::= DecimalDigit+

OctalInteger ::= "0o" OctalDigit+

BinaryInteger ::= "0b" BinaryDigit+

Float ::= DecimalDigit+ "." DecimalDigit+ NumberSuffix?

NumberSuffix ::= Alpha AlphaNumeric*

HexDigit ::= DecimalDigit
           | "a" | "b" | "c" | "d" | "e" | "f"
           | "A" | "B" | "C" | "D" | "E" | "F"

DecimalDigit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

OctalDigit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7"

BinaryDigit ::= "0" | "1"

String ::= StringStart StringPart* StringEnd

StringStart ::= '"'

StringEnd ::= '"'

StringPart ::= StringText
             | StringInterpolation

StringInterpolation ::= StringExprStart Expr StringExprEnd

StringExprStart ::= "{"

StringExprEnd ::= "}"

LambdaLiteral ::= "->" LambdaParameterDecl? BlockOrExpr

LambdaParameterDecl ::= "|" NameDecl* "|" TypeAnnotation?

TupleLiteral ::= "(" ")"
               | "(" Expr "," ")"
               | "(" Expr* ")"

ListLiteral ::= "[" "]"

MapLiteral ::= ".{" "}"

Boolean ::= "true"
          | "false"

// ------ Misc ------

UnpackTarget ::= "(" UnpackTargetItem* ")"
               | "{" UnpackTargetItem* "}"

UnpackTargetItem ::= Id
                   | Expr
                   | "..."

ConditionTarget ::= Expr
                  | ("const" | "let") Type UnpackTarget? "=" Expr

AttributeList ::= Attribute*

Attribute ::= "@" Id AttributeArguments?

AttributeArguments ::= "(" Expr* ")"
