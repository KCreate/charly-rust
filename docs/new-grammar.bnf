// MIT License
//
// Copyright (c) 2025 Leonard SchÃ¼tz
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// ------ Grammar ------

Program ::= TopLevelItem*

TopLevelItem ::= ImportDecl
               | FnDecl
               | VarDecl
               | TypeAliasDecl
               | StructDecl
               | InterfaceDecl
               | EnumDecl
               | ImplDecl
               | Stmt

// ------ Import Statement ------

ImportDecl ::= Attribute* "import" ImportTarget

ImportTarget ::= ImportSingle
             | ImportWildcard

ImportSingle ::= ImportPath ImportAsItem?

ImportWildcard ::= ImportPath "::" "*"

ImportPath ::= Id ("::" Id)*

ImportAsItem ::= "as" Id

// ------ Declarations ------

DeclMod ::= "export"
          | "internal"
          | "public"
          | "private"
          | "static"
          | "final"

// ------ Function Declaration ------

FnDecl ::= Attribute* DeclMod* "fn" Id GenericParamList? FnParamList? FnReturnAnnot? FnBody

FnParamList ::= "(" (FnParam ("," FnParam)*)? ")"

FnParam ::= "..."? NameDecl

FnReturnAnnot ::= "->" Type

FnBody ::= FnExprBody
         | FnBlockBody

FnExprBody ::= "=" ExprLikeStmt

FnBlockBody ::= Block

// ------ Variable Declarations ------

VarDecl ::= Attribute* DeclMod* ("const" | "let") VarDeclTarget ("=" Expr)?

VarDeclTarget ::= NameDecl
                | UnpackTarget

// ------ Typealias Declarations ------

TypeAliasDecl ::= Attribute* DeclMod* "type" Id GenericParamList? ("=" Type)?

// ------ Struct Declarations ------

StructDecl ::= Attribute* DeclMod* "struct" Id GenericParamList? StructBody

StructBody ::= "{" StructItem* "}"

StructItem ::= VarDecl
             | TypeAliasDecl

// ------ Interface Declarations ------

InterfaceDecl ::= Attribute* DeclMod* "interface" Id GenericParamList? InterfaceExtends* InterfaceBody

InterfaceExtends ::= "extends" Type

InterfaceBody ::= "{" InterfaceItem* "}"

InterfaceItem ::= FnDecl
                | TypeAliasDecl

// ------ Enum Declarations ------

EnumDecl ::= Attribute* DeclMod* "enum" GenericParamList? EnumBody

EnumBody ::= "{" EnumItem ("," EnumItem)* "}"

EnumItem ::= Id EnumItemParams?

EnumItemParams ::= "(" NameDecl ("," NameDecl)* ")"

// ------ Impl Declarations ------

ImplDecl ::= Attribute* "impl" GenericParamList? ImplTarget ImplBody

ImplTarget ::= ImplTypeTarget
             | ImplInterfaceTarget

ImplTypeTarget ::= Type

ImplInterfaceTarget ::= Type "for" Type

ImplBody ::= "{" ImplItem* "}"

ImplItem ::= FnDecl
           | TypeAliasDecl

// ------ Statements ------

Block ::= "{" Stmt* "}"

Stmt ::= VarDecl
       | ImportDecl
       | DeferStmt
       | ExprLikeStmt

ExprLikeStmt ::= "return" Expr?
               | "break"
               | "continue"
               | ForStmt
               | WhileStmt
               | LoopStmt
               | Expr

BlockOrExpr ::= Block | ExprLikeStmt

// ------ Defer Statement ------

DeferStmt ::= "defer" BlockOrExpr

// ------ For Statement ------

ForStmt ::= "for" VarDeclTarget "in" Expr "do" BlockOrExpr

// ------ While Statement ------

WhileStmt ::= "while" ConditionTarget "do" BlockOrExpr

// ------ If Statement ------

IfStmt ::= "if" ConditionTarget "do" BlockOrExpr IfElseCase?

IfElseCase ::= "else" BlockOrExpr

// ------ Loop Statement ------

LoopStmt ::= "loop" BlockOrExpr

// ------ Match Statement ------

MatchStmt ::= "match" Expr? MatchBody

MatchBody ::= "{" MatchArm* "}"

MatchArm ::= MatchPattern MatchPatternCondition? "=>" BlockOrExpr

MatchPattern ::= MatchPatternTuple
               | MatchPatternExpr
               | MatchPatternIs
               | MatchPatternIn
               | MatchPatternElse

MatchPatternTuple ::= TupleLiteral

MatchPatternExpr ::= Expr

MatchPatternIs ::= "is" Type UnpackTarget?

MatchPatternIn ::= "in" Expr

MatchPatternElse ::= "else"

MatchPatternCondition ::= "if" Expr

// ------ Select Statement ------

SelectStmt ::= "select" SelectBody

SelectBody ::= "{" SelectArm* "}"

SelectArm ::= SelectWhenArm
            | SelectElseArm

SelectWhenArm ::= "when" Expr SelectArmResultHandler

SelectElseArm ::= "else" SelectArmResultHandler

SelectArmResultHandler ::= "=>" BlockOrExpr

// ------ Expressions ------

Expr ::= Expr InfixOp Expr
       | PrefixOp Expr
       | Expr PostfixOp
       | Expr PostfixExpr
       | Expr ("as" | "as?") Type
       | IfStmt
       | MatchStmt
       | SelectStmt
       | Literal

PostfixExpr ::= GenericArgumentList
              | PostfixCallExpr
              | PostfixIndexExpr
              | PostfixMemberExpr
              | PostfixPathExpr

PostfixCallExpr ::= CallArgumentList
                  | CallArgumentList? LambdaLiteral

CallArgumentList ::= "(" (CallArgument ("," CallArgument)*)? ")"

CallArgument ::= Expr
               | "." Id "=" Expr

PostfixIndexExpr ::= "[" Expr ("," Expr)* "]"

PostfixMemberExpr ::= "." Id

PostfixPathExpr ::= "::" Id

// ------ Types ------

Type ::= TypePathItem ("::" TypePathItem)* "?"

TypePathItem ::= Id GenericArgumentList

GenericParamList ::= "<" GenericParamItem ("," GenericParamItem)* ">"

GenericParamItem ::= Id (":" Type ("&" Type)*)?

GenericArgumentList ::= "<" Type ("," Type)* ">"

NameDecl ::= Id TypeAnnotation?

TypeAnnotation ::= ":" Type

// ------ Literals ------

Literal ::= Id
          | String
          | FormatString
          | Integer
          | Float
          | "true" | "false"
          | "null"
          | LambdaLiteral
          | "(" Expr ")"
          | TupleLiteral
          | ListLiteral
          | MapLiteral
          | Block

Id ::= "identifier"

FormatString ::= (FormatStringPart Expr)+ String

LambdaLiteral ::= "->" LambdaParameterDecl? BlockOrExpr

LambdaParameterDecl ::= "|" LambdaParameterList? "|" TypeAnnotation?

LambdaParameterList ::= NameDecl ("," NameDecl)*

TupleLiteral ::= "(" ")"
               | "(" Expr "," ")"
               | "(" Expr ("," Expr)* ")"

ListLiteral ::= "[" "]"

MapLiteral ::= ".{" "}"

// ------ Misc ------

UnpackTarget ::= "(" (UnpackTargetItem ("," UnpackTargetItem)*)? ")"
               | "{" (UnpackTargetItem ("," UnpackTargetItem)*)? "}"

UnpackTargetItem ::= Id
                   | Expr
                   | "..."

ConditionTarget ::= Expr
                  | ("const" | "var") Type UnpackTarget? "=" Expr

Attribute ::= "#" "[" AttributeArguments? "]"

AttributeArguments ::= AttributeItem ("," AttributeItem)*

AttributeItem ::= AttributeKey
                | AttributeKey "=" AttributeValue?
                | AttributeKey "(" AttributeArguments? ")"

AttributeKey ::= Id

AttributeValue ::= String
                 | Integer
                 | Float
                 | Boolean
